import serial, time, sys
sys.setrecursionlimit(10000)

# CONFIG
PORT, BAUD = 'COM5', 9600
ROWS, COLS = 3, 3
CELL_DELAY, TURN_DELAY = 0.6, 0.5
DIST_THRESHOLD = 10

ser = serial.Serial(PORT, BAUD, timeout=1)
time.sleep(2)
dirs = [(-1,0),(0,1),(1,0),(0,-1)]  # 0=up,1=right,2=down,3=left

def send(cmd):
    ser.write(cmd.encode()); time.sleep(0.05)
def move_forward(): send('F'); time.sleep(CELL_DELAY)
def turn_left():    send('L'); time.sleep(TURN_DELAY)
def turn_right():   send('R'); time.sleep(TURN_DELAY)
def turn_around():  send('B'); time.sleep(2*TURN_DELAY)

def get_distance():
    send('D')
    line = ser.readline().strip()
    print(float(line))
    return float(line) if line else 0

def rotate(frm, to):
    diff = (to - frm) % 4
    if diff == 1:   turn_right()
    elif diff == 2: turn_around()
    elif diff == 3: turn_left()

def dfs(r, c, ori, visited):
    visited.add((r, c))
    orig = ori
    for i in range(4):
        nd = (orig + i) % 4
        dr, dc = dirs[nd]
        nr, nc = r+dr, c+dc
        if not (0<=nr<ROWS and 0<=nc<COLS) or (nr,nc) in visited:
            continue
        # check wall
        while get_distance() < DIST_THRESHOLD:
            rotate(nd, ori)
            get_distance()

        # go forward
        move_forward()
        dfs(nr, nc, nd, visited)
        time.sleep(CELL_DELAY)
        # backtrack to (r,c)
        turn_around(), move_forward(), turn_around()

        rotate(nd, orig)
        ori = orig

if __name__=='__main__':
    try:
        dfs(2, 1, 0, set())  # start top-left facing right
    finally:
        ser.close()
